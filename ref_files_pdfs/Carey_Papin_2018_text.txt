[1] " EDITORIAL\n\n Ten simple rules for biologists learning to\n program\n Maureen A. Carey1, Jason A. Papin2*\n 1 Department of Microbiology, Immunology, and Cancer Biology, University of Virginia School of Medicine,\n Charlottesville, Virginia, United States of America, 2 Department of Biomedical Engineering, University of\n Virginia, Charlottesville, Virginia, United States of America\n\n * papin@virginia.edu\n\n\n Introduction\n As big data and multi-omics analyses are becoming mainstream, computational proficiency\n and literacy are essential skills in a biologist’s tool kit. All “omics” studies require computa-\n tional biology: the implementation of analyses requires programming skills, while experimen-\n tal design and interpretation require a solid understanding of the analytical approach. While\n academic cores, commercial services, and collaborations can aid in the implementation of\n analyses, the computational literacy required to design and interpret omics studies cannot be\na1111111111 replaced or supplemented. However, many biologists are only trained in experimental tech-\na1111111111 niques. We write these 10 simple rules for traditionally trained biologists, particularly graduate\na1111111111 students interested in acquiring a computational skill set.\na1111111111\na1111111111\n Rule 1: Begin with the end in mind\n When picking your first language, focus on your goal. Do you want to become a programmer?\n Do you want to design bioinformatic tools? Do you want to implement tools? Do you want to\n OPEN ACCESS\n just get these data analyzed already? Pick an approach and language that fits your long- and\n short-term goals.\nCitation: Carey MA, Papin JA (2018) Ten simple\n Languages vary in intent and usage. Each language and package was created to solve a par-\nrules for biologists learning to program. PLoS\nComput Biol 14(1): e1005871. https://doi.org/\n ticular problem, so there is no universal “best” language (Fig 1). Pick the right tool for the job\n10.1371/journal.pcbi.1005871 by choosing a language that is well suited for the biological questions you want to ask. If many\n people in your field use a language, it likely works well for the types of problems you will\nEditor: Scott Markel, Dassault Systemes BIOVIA,\nUNITED STATES\n encounter. If people in your field use a variety of languages, you have options. To evaluate ease\n of use, consider how much community support a language has and how many resources that\nPublished: January 4, 2018\n community has created, such as prevalence of user development, package support (documen-\nCopyright: © 2018 Carey, Papin. This is an open tation and tutorials), and the language’s “presence” on help pages. Practically, languages vary\naccess article distributed under the terms of the in cost for academic and commercial use. Free languages are more amenable to open source\nCreative Commons Attribution License, which\n work (i.e., sharing your analyses or packages). See Table 1 for a brief discussion of several pro-\npermits unrestricted use, distribution, and\nreproduction in any medium, provided the original\n gramming languages, their key features, and where to learn more.\nauthor and source are credited.\n\nFunding: The authors received no specific funding Rule 2: Baby steps are steps\nfor this work.\n Once you’ve begun, focus on one task at a time and apply your critical thinking and problem\nCompeting interests: The authors have declared solving skills. This requires breaking a problem down into steps. Analyzing omics data may\nthat no competing interests exist. sound challenging, but the individual steps do not: e.g., read your data, decide how to interpret\nJason A. Papin is co-Editor-in-Chief of PLOS missing values, scale as needed, identify comparison conditions, divide to calculate fold\nComputational Biology. change, calculate significance, correct for multiple testing. Break a large problem into modular\n\n\n\nPLOS Computational Biology |   January 4, 2018 1 / 11\n" 
 [2] " Fig 1. The “one tool to rule them all” (or: how programming languages do not work).\n  .g001\n\n tasks and implement one task at a time. Iteratively edit for efficiency, flow, and succinctness.\n Mistakes will happen. That’s ok; what matters is that you find, correct, and learn from them.\n\n\n\n Rule 3: Immersion is the best learning tool\n Don’t stitch together an analysis by switching between or among languages and/or point and\n click environments (Excel [Microsoft; https://www.microsoft.com/en-us/], etc.). While learn-\n ing, if a job can be done in one language or environment, do it all there. For example, import-\n ing a spreadsheet of data (like you would view in Excel) is not necessarily straightforward;\n Excel automatically determines how to read text, but the method may differ from conventions\n in other programming languages. If the import process “misreads” your data (e.g., blank cells\n are not read as blank or “NA,” numbers are in quotes indicating that they are read as text, or\n column names are not maintained), it can be tempting to return to Excel to fix these with\n search-and-replace strategies. However, these problems can be fixed by correctly reading the\n data and by understanding the language’s data structures. Just like a spoken language [1, 2],\n immersion is the best learning tool [3, 4]. In addition to slowing the learning curve, transfer-\n ring across programs induces error. See References [5–7] for additional Excel or word process-\n ing–induced errors.\n Eventually, you may identify tasks that are not well suited to the language you use. At that\n point, it may be helpful to pick up another language in order to use the right tool for the job\n\n\n\nPLOS Computational Biology |   January 4, 2018 2 / 11\n"  
 [3] "Table 1. A noninclusive discussion of programming languages. A shell is a command line (i.e., programming) interface to an operating system, like\nUnix operating systems. Low-level programming languages deal with a computer’s hardware. The process of moving from the literal processor instructions\ntoward human-readable applications is called “abstraction.” Low-level languages require little abstraction. Interpreted languages are quicker to test (e.g., to\nrun a few lines of code); this facilitates learning through trial and error. Interpreted languages tend to be more human readable. Compiled languages are pow-\nerful because they are often more efficient and can be used for low-level tasks. However, the distinction between interpreted and compiled languages is not\nalways rigid. All languages presented below are free unless noted otherwise. The Wikipedia page on programming languages provides a great overview and\ncomparison of languages.\nLanguage Key features Documentation Sample tutorials Community groups\nBash • Most common Unix shell • gnu.org/software/bash/manual/ • The Linux Documentation • Google Plus: plus.google.com/\n • Practical for execution of • On macOS’s terminal, type “man Project’s Beginner’s guide: tldp. communities/\n scripts written in all other <command>” to get the manual for org/LDP/Bash-Beginners-Guide/ 110832059019676429606\n languages any command (and “q” to exit html/ • GitHub community resources page:\n • Versatile manual page) • Ubuntu’s documentation: help. github.com/awesome-lists/\n • Easy to delete files or make ubuntu.com/community/ awesome-bash\n other drastic changes Beginners/BashScripting\n • Weaknesses include • Azet’s GitHub page: github.com/\n executing math and limited azet/community_bash_style_\n data structures guide\n • Default for macOS and\n most Linux distributions\nPython • General purpose language • docs.python.org • Google’s Python class: • Python Users Group: wiki.python.\n • Considered easy to learn developers.google.com/edu/ org/moin/LocalUserGroups\n due to readability python/ • Python Special Interest Groups:\n • Flexible syntax considered • The Hitchhiker’s Guide to python.org/community/sigs/\n both a strength and Python: docs.python-guide.org/\n weakness\n • Interpreted language\nR • Community involvement • rdocumentation.org • R for cats: rforcats.net • R-Ladies: rladies.org\n • Application-focused • r-project.org • Books by Hadley Wickham: • R Users Group: many\n development • cran.r-project.org hadley.nz\n • Easy to learn by coupling • R Tutorial’s introduction: r-tutor.\n basic programming and com/r-introduction\n applications • Cyclismo’s R Tutorial: cyclismo.\n • Well-developed org/tutorial/R/\n visualization\n • Variable package quality\n • “Tidy data” community\n • Interpreted language\nSAS • Statistical computing • support.sas.com • Boston University’s SAS • SAS User Groups: sas.com/en_us/\n • High-quality development Training for Statistics: bu.edu/ connect/user-groups.html\n of statistical functions by stat/bu-student-chapter-of-the-\n commercial and academic asa/sas-training/\n developers\n • Domain-specific usage\n • Free for students only\n • Typically a compiled\n language\nMATLAB • Well-developed • mathworks.com/help/matlab • Cyclismo’s MATLAB Tutorial: • MATLAB Central: mathworks.com/\n applications in engineering cyclismo.org/tutorial/matlab/ matlabcentral/\n • Maintained professionally • For purchase courses offered at:\n • Interpreted language matlabacademy.mathworks.com\n • Discounted academic\n license\nPerl • General purpose language • perl.org • Beginning Perl: perl.org/books/ • Perl Mongers: pm.org\n • Handles text well • cpan.org beginning-perl/ • Perl Monks: perlmonks.org\n • Waning community • Perl maven’s tutorial:\n involvement perlmaven.com\n • Syntax modelled after • Perl::Learn: learn.perl.org\n human language\n • Interpreted language\n (Continued)\n\n\n\n\nPLOS Computational Biology |   January 4, 2018 3 / 11\n"
 [4] "Table 1. (Continued)\n\nLanguage Key features Documentation Sample tutorials Community groups\nFortran • Numeric computation • fortranwiki.org • many at Fortran wiki: fortranwiki. • Fortran Friends: fortran.\n • Fast org/fortran/show/Tutorials orpheusweb.co.uk\n • Often used for high-\n performance computing\n • Limited development\n • Compiled language\nC/C++ • Low-level language • devdocs.io/c • C programming’s tutorial: • Standard C++ Foundation: isocpp.\n • Powerful, used for source • cppreference.com cprogramming.com/tutorial/ org\n code of many other • Learn-C’s web-based tutorial: • C/C++ Users Group (CUG): hal9k.\n languages learn-c.org com/cug\n • Challenging to learn as it\n requires explicit syntax\n • Explicit syntax enforces\n good programming habits\n • Compiled language\n .t001\n\n\n (see Rule 1). In fact, understanding one language will make it easier to learn a second. Until\n then, however, focus on immersion to learn.\n\n\n Rule 4: Phone a friend\n There are numerous online resources: tutorials, documentation, and sites intended for com-\n munity Q and A (StackOverflow, StackExchange, Biostars, etc.), but nothing replaces a friend\n or colleague’s help. Find a community of programmers, ranging from beginning to experi-\n enced users, to ask for help. You may want to look for both technical support (i.e., a group cen-\n tered around a language) and support regarding a particular scientific application (e.g., a\n group centered around omics analyses). Many universities have scientific computing groups,\n housed in the library or information technology (IT) department; these groups can be your\n starting point. If your lab or university does not have a community of programmers, seek\n them out virtually or locally. Coursera courses, for example, have comment boards for students\n to answer each other’s questions and learn from their peers. Organizations like Software and\n Data Carpentry or language user groups have mailing lists to connect members. Many cities\n have events organized by language-specific user groups or interest groups focused on big data,\n machine learning, or data visualization. These can be found through meetup.com, Google\n groups, or through a user group’s website; some are included in Table 1.\n Once you find a community, ask for help. At the beginning stages, in-person help to decon-\n struct or interpret an online answer is invaluable. Additionally, ask a friend for code. You\n wouldn’t write a paper without first reading a lot of papers or begin a new project without\n shadowing a few experimenters. First, read their code. Implement and interpret, trying to\n understand each line. Return to discuss your questions. Once you begin writing, ask for edits.\n\n\n Rule 5: Learn how to ask questions\n There’s an answer to almost anything online, but you have to know what to ask to get help. In\n order to know what to ask, you have to understand the problem. Start by interpreting an error\n message. Watch for generic errors and learn from them. Identify which component of your\n error message indicates what the issue is and which component indicates where the issue is\n (Figs 2–5). Understanding the problem is essential; this process is called “debugging.” Without\n truly understanding the problem, any “solution” will ultimately propagate and escalate the\n mistake, making harder-to-interpret errors down the road. Once you understand the problem,\n\n\n\nPLOS Computational Biology |   January 4, 2018 4 / 11\n" 
 [5] "Fig 2. Anatomy of an error message, Part 1 (or: How to write more than one line of code). Here we show an example of the debugging process in R\nusing the RStudio environment, with the goal of concatenating two words.\n .g002\n\n look for answers. Looking for answers requires effective googling. Learn the vocabulary (and\n meta-vocabulary) of the language and its users. Once you understand the problem and have\n identified that there is no obvious (and publicly available) solution, ask for answers in pro-\n gramming communities (see Rule 4 and Table 1). When asking, paraphrase the fundamental\n problem. Include error messages and enough information to reproduce the problem (include\n packages, versions, data or sample data, code, etc.). Present a brief summary of what was done,\n what was intended, how you interpret the problem, what troubleshooting steps were already\n taken, and whether you have searched other posts for the answer.\n See the following website for suggestions: http://codereview.stackexchange.com/help/how-\n to-ask and [8]. End with a “thank you” and wait for the help to arrive.\n\n\n\n Rule 6: Don’t reinvent the wheel\n Rule 6 can also be found in “Ten Simple Rules for the Open Development of Scientific Soft-\n ware” [9], “Ten Simple Rules for Developing Public Biological Databases” [10], “Ten Simple\n Rules for Cultivating Open Science and Collaborative R&D” [11], and “Ten Simple Rules To\n Combine Teaching and Research” [12]. Use all resources available to you, including online\n tutorials, examples in the language’s documentation, published code, cool snippets of code\n your labmate shared, and, yes, your own work. Read widely to identify these resources. Copy-\n and-paste is your friend. Provide credit if appropriate (i.e., comment “adapted from so-n-so’s\n X script”) or necessary (e.g., read through details on software licenses). Document your scripts\n by commenting in notes to yourself so that you can use old code as a template for future work.\n\n\n\nPLOS Computational Biology |   January 4, 2018 5 / 11\n"  
 [6] "Fig 3. Anatomy of an error message, Part 2 (or: Just because it works, doesn’t mean it’s right). Here we provide more examples of the debugging\nprocess. Examples shown in Figs 3–5 are conducted in Python using a Jupyter notebook. Environments like RStudio (in Fig 2) and Jupyter notebooks are two\nexamples of integrated development environments; these environments offer additional support, including built-in debugging tools. First, we show an error\nthat does not induce an error message, but the user must debug nonetheless.\n .g003\n\n These comments will help you remember what each line of code intends to do, accelerating\n your ability to find mistakes.\n\n Rule 7: Develop good habits early on\n Computational research is research, so use your best practices. This includes maintaining a\n computational lab notebook and documenting your code. A computational lab notebook is by\n definition a lab notebook: your lab notebook includes protocols, so your computational lab\n notebook should include protocols, too. Computational protocols are scripts, and these should\n include the code itself and how to access everything needed to implement the code. Include\n\n\n\nPLOS Computational Biology |   January 4, 2018 6 / 11\n"   
 [7] "Fig 4. Anatomy of an error message, Part 3 (or: Trace your way back to the problem). Here we show an explicit error message.\n .g004\n\n input (raw data) and output (results), too. Figures and interpretation can be included if that’s\n how you organize your lab notebook. Develop computational “place habits” (file-saving strate-\n gies). It is easier to organize one drawer than it is to organize a whole lab, so start as soon as\n you begin to learn to program. If you can find that experiment you did on June 12, 2011—its\n protocol and results—in under five minutes, you should be able to find that figure you gener-\n ated for lab meeting three weeks ago, complete with code and data, in under five minutes as\n well. This requires good version control or documentation of your work. Like with protocols,\n\n\n\n\nPLOS Computational Biology |   January 4, 2018 7 / 11\n"   
 [8] "Fig 5. Anatomy of an error message, Part 4 (or: Debugging a solution). Lastly, we show how to debug a solution to understand a line of code found on\nthe internet.\n .g005\n\n\n\n\nPLOS Computational Biology |   January 4, 2018 8 / 11\n"    
 [9] " Fig 6. “How to exit the vim editor?” (or: We all get stuck at some point). Now viewed >1.33 million times;\n see: http://stackoverflow.com/questions/11828270/how-to-exit-the-vim-editor.\n  .g006\n\n each time you run a script, you should note any modifications that are made. Document all\n changes in experimental and computational protocols. These habits will make you more effi-\n cient by enhancing your work’s reproducibility. For specific advice, see “Ten Simple Rules for\n a Computational Biologist’s Laboratory Notebook” [13], “Ten Simple Rules for Reproducible\n Computational Research” [14], and “Ten Simple Rules for Taking Advantage of Git and\n GitHub” [15].\n\n Rule 8: Practice makes perfect\n Use toy datasets to practice a problem or analysis. Biological data get big, fast. It’s hard to find\n the computational needle-in-a-haystack, so set yourself up to succeed by practicing in con-\n trolled environments with simpler examples. Generate small toy datasets that use the same\n structure as your data. Make the toy data simple enough to predict how the numbers, text, etc.,\n should react in your analysis. Test to ensure they do react as expected. This will help you\n understand what is being done in each step and troubleshoot errors, preparing you to scale up\n to large, unpredictable datasets. Use these datasets to test your approach, your implementation,\n and your interpretation. Toy datasets are your negative control, allowing you to differentiate\n between negative results and simulation failure.\n\n Rule 9: Teach yourself\n How would you teach you if you were another person? You would teach with a little more\n patience and a bit more empathy than you are practicing now. You are not alone in your occa-\n sional frustration (Fig 6). Learning takes time, so plan accordingly. Introductory courses are\n helpful to learn the basics because the basics are easy to neglect in self-study. Articulate clear\n expectations for yourself and benchmarks for success. Apply some of the structure (deadlines,\n assignments, etc.) you would provide a student to help motivate and evaluate your progress. If\n something isn’t working, adjust; not everyone learns best by any one approach. Explore tuto-\n rials, online classes, workshops, books like Practical Computing for Biologists [16], local pro-\n gramming meetups, etc., to find your preferred approach.\n\n Rule 10: Just do it\n Just start coding. You can’t edit a blank page.\n\n\n\nPLOS Computational Biology |   January 4, 2018 9 / 11\n"  
[10] " Learning to program can be intimidating. The power and freedom provided in conducting\n your own computational analyses bring many decisions points, and each decision brings more\n room for mistakes. Furthermore, evaluating your work is less black-and-white than for some\n experiments. However, coding has the benefit that failure is risk free. No resources are wasted\n —not money, time (a student’s job is to learn!), or a scientific reputation. In silico, the playing\n field is leveled by hard work and conscientiousness. So, while programming can be intimidat-\n ing, the most intimidating step is starting.\n\n Conclusion\n Markowetz recently wrote, “Computational biologists are just biologists using a different tool”\n [17]. If you are a traditionally trained biologist, we intend these 10 simple rules as instruction\n (and pep talk) to learn a new, powerful, and exciting tool. The learning curve can be steep;\n however, the effort will pay dividends. Computational experience will make you more market-\n able as a scientist (see “Top N Reasons To Do A Ph.D. or Post-Doc in Bioinformatics/Compu-\n tational Biology” [18]). Computational research has fewer overhead costs and reduces the\n barrier to entry in transitioning fields [19], opening career doors to interested researchers. Per-\n haps most importantly, programming skills will make you better able to implement and inter-\n pret your own analyses and understand and respect analytical biases, making you a better\n experimentalist as well. Therefore, the time you spend at your computer is valuable. Acquiring\n programming expertise will make you a better biologist.\n\n Acknowledgments\n Thank you to Ed Hall, Pat Schloss, Matthew Jenior, Angela Zeigler, Jhansi Leslie, and Gregory\n Medlock for their feedback.\n\n References\n 1. Genesee F. Integrating language and content: Lessons from immersion. Center for Research on Edu-\n cation, Diversity & Excellence. 1994.\n 2. Genesee FH, editor Second language learning in school settings: Lessons from immersion1991: Law-\n rence Erlbaum Associates.\n 3. Campbell W, Bolker E, editors. Teaching programming by immersion, reading and writing2002: IEEE.\n 4. Guzdial M. Programming environments for novices. Computer science education research. 2004;\n 2004:127–54.\n 5. Zeeberg BR, Riss J, Kane DW, Bussey KJ, Uchio E, Linehan WM, et al. Mistaken identifiers: gene\n name errors can be introduced inadvertently when using Excel in bioinformatics. BMC Bioinformatics.\n 2004; 5(1):80.\n 6. Ziemann M, Eren Y, El-Osta A. Gene name errors are widespread in the scientific literature. Genome\n Biol. 2016; 17(1):177. https://doi.org/10.1186/s13059-016-1044-7 PMID: 27552985\n 7. Linke D. Commentary: Never trust your word processor. Biochemistry and Molecular Biology Educa-\n tion. 2009; 37(6):377–. https://doi.org/10.1002/bmb.20340 PMID: 21567776\n 8. Collado-Torres L. Recent Posts [Internet]2017. [cited 2017]. Available from: http://lcolladotor.github.io/.\n Posts. Accessed on 5 April 2017.\n 9. Prlić A, Procter JB. Ten simple rules for the open development of scientific software. PLoS Comput Biol.\n 2012; 8(12):e1002802. https://doi.org/10.1371/journal.pcbi.1002802 PMID: 23236269\n 10. Helmy M, Crits-Christoph A, Bader GD. Ten Simple Rules for Developing Public Biological Databases.\n PLoS Comput Biol. 2016; 12(11):e1005128. https://doi.org/10.1371/journal.pcbi.1005128 PMID:\n 27832061\n 11. Masum H, Rao A, Good BM, Todd MH, Edwards AM, Chan L, et al. Ten simple rules for cultivating\n open science and collaborative R&D. PLoS Comput Biol. 2013; 9(9):e1003244. https://doi.org/10.1371/\n journal.pcbi.1003244 PMID: 24086123\n 12. Vicens Q, Bourne PE. Ten simple rules to combine teaching and research. PLoS Comput Biol. 2009; 5\n (4):e1000358. https://doi.org/10.1371/journal.pcbi.1000358 PMID: 19390598\n\n\n\n\nPLOS Computational Biology |   January 4, 2018 10 / 11\n" 
[11] " 13. Schnell S. Ten Simple Rules for a Computational Biologist’s Laboratory Notebook. PLoS Comput Biol.\n 2015; 11(9):e1004385. https://doi.org/10.1371/journal.pcbi.1004385 PMID: 26356732\n 14. Sandve GK, Nekrutenko A, Taylor J, Hovig E. Ten simple rules for reproducible computational research.\n PLoS Comput Biol. 2013; 9(10):e1003285. https://doi.org/10.1371/journal.pcbi.1003285 PMID:\n 24204232\n 15. Perez-Riverol Y, Gatto L, Wang R, Sachsenberg T, Uszkoreit J, da Veiga Leprevost F, et al. Ten Simple\n Rules for Taking Advantage of Git and GitHub. PLoS Comput Biol. 2016; 12(7):e1004947. https://doi.\n org/10.1371/journal.pcbi.1004947 PMID: 27415786\n 16. Haddock SHD, Dunn CW. Practical computing for biologists: Sinauer Associates Sunderland, MA;\n 2011.\n 17. Markowetz F. All biology is computational biology. PLoS Biol. 2017; 15(3):e2002050. https://doi.org/10.\n 1371/journal.pbio.2002050 PMID: 28278152\n 18. Bergman C. An Assembly of Fragments [Internet]. [cited 2017]. Available from: https://caseybergman.\n wordpress.com/2012/07/31/top-n-reasons-to-do-a-ph-d-or-post-doc-in-bioinformaticscomputational-\n biology/. Accessed on 5 April 2017.\n 19. Kwok R. Nature: Careers [Internet]: Nature Publishing Group. 2013. [cited 2017].\n\n\n\n\nPLOS Computational Biology |   / 11\n"   
